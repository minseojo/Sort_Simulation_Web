<!DOCTYPE html>
<html lang="en">
<head>
    <title>Bubble-Sort</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href ="1.css">
</head>

<body>
    <h1 style="color: aliceblue;">삽입 정렬(Insertion Sort)</h1>
    <img src = "2.jpg">
    <h3 style="color: aliceblue;">시간 복잡도: O(n²)</h3>
    <h3 style="color: aliceblue;">삽입 정렬을 실행했을 때 나오는 그림.</h3>

    <p>
        삽입 정렬을 알기 쉽게 만든 그림. 선택 정렬과 함께 인간에게 뭔가를 정렬하라고 하면 무의식적으로 사용하는 대표적인 알고리즘이다.
    
        k번째 원소를 1부터 k-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식으로, 평균적으론 \mathcal{O}(n^2)O(n 
        2
         )중 빠른 편이나[15] 자료구조에 따라선 뒤로 밀어내는데 걸리는 시간이 크며, 앞의 예시처럼 작은 게 뒤쪽에 몰려있으면(내림차순의 경우 큰 게 뒤쪽에 몰려있으면) 그야말로 헬게이트다.
        다만 이미 정렬되어 있는 자료구조에 자료를 하나씩 삽입/제거하는 경우에는 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문이다. 괜히 '삽입'이란 이름이 붙은 것이 아니다.
        
        그밖에도 배열이 작을 경우에 역시 상당히 효율적이다. 일반적으로 빠르다고 알려진 알고리즘들도 배열이 작을 경우에는 대부분 삽입 정렬에 밀린다. 따라서 고성능 알고리즘들 중에서는 배열의 사이즈가 클때는 \mathcal{O}(n\log n)O(nlogn) 알고리즘을 쓰다가 정렬해야 할 부분이 작을때 는 삽입 정렬로 전환하는 것들도 있다.
        
        또 굳이 장점을 뽑자면 구현이 매우 쉽다는 것. 그 예로 C/C++에서 기본적인 삽입 정렬을 구현하는데는 서너줄의 코드면 충분하다.
        
        
        파생형으로 이진 삽입 정렬(Binary insertionSort)이 있다. 이진 탐색을 활용해 새로운 원소가 위치할 곳을 미리 찾아서 정렬하는 방식이다. 원소크기를 비교하는 조건 부분을 \log{n}logn 수준으로 낮춰 조금은 더 빠르게 수행할 수 있다는 점 정도.
    </p>
    
    <video id="video" preload="auto" autoplay="true" loop="loop" muted="muted" volume="0">
        <source src="insertion.mp4">
    </video>
    <h3><a href="tag.html">뒤로가기</a></h3>

    
</body>