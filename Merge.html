<!DOCTYPE html>
<html lang="en">
<head>
    <title>Merge-Sort</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href ="style.css">
    <style>
        
ol { 
    font-size: 20px;
    text-align: right;
    position: absolute;
    top:80%;
    left:20%;
}
a { text-decoration:none;} 
a:link { color:#4875b4; font-size: 12px;}
a:visited { color:#4875b4;
font-size: 12px;}
    </style>
</head>
<body style="background-color: white;">

    <div style="border-bottom: 1px solid rgb(114, 110, 110); width: 95%; padding: 30px;"> </div>

    <h1 style="color:#3863a0;; text-align-last: center; margin-top: 28px; margin-right: 20px;">Merge Sort</h1>
   
    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position: absolute; top:16%; left:0%;">ALGORITHM</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position: absolute; top:23%; left:2%; ">
        # split in half<br>
        m = n / 2<br>
        <br>
        # recursive sorts<br>
        sort a[1..m]<br>
        sort a[m+1..n]<br>
        <br>
        # merge sorted sub-arrays using temp array<br>
        b = copy of a[1..m]<br>
        i = 1, j = m+1, k = 1<br>
        while i <= m and j <= n,<br>
        &nbsp;  &nbsp;   a[k++] = (a[j] < b[i]) ? a[j++] : b[i++]<br>
        &nbsp;  &nbsp;      → invariant: a[1..k] in final position<br>
        while i <= m,<br>
        &nbsp;  &nbsp;      a[k++] = b[i++]<br>
        &nbsp;  &nbsp;      → invariant: a[1..k] in final position<br>
        end
    </span>
    <canvas id="myCanvas" width="460" height="200"></canvas>
    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:16%; left:69.5%;">DISCUSSION</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position:absolute; top:23%; left:71.5%; width: 350px;">
        Merge sort is very predictable. It makes between 0.5lg(n) and lg(n) comparisons per element, and between lg(n) and 1.5lg(n) swaps per element. The minima are achieved for already sorted data; the maxima are achieved, on average, for random data. If using Θ(n) extra space is of no concern, then merge sort is an excellent choice: It is simple to implement, and it is the only stable O(n·lg(n)) sorting algorithm. Note that when sorting linked lists, merge sort requires only Θ(lg(n)) extra space (for recursion).
    </span>

    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:65%; left:69.5%;">PROPERTIES</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position:absolute; top:72%; left:71.5%">
        • Stable<br>
        • Θ(n) extra space for arrays (as shown)<br>
        • Θ(lg(n)) extra space for linked lists<br>
        • Θ(n·lg(n)) time<br>
        • Not adaptive <br>
        • Does not require random access to data
    </span>
<!-- 오픈 -->
    <div class="file_input_div">
        <div class="button-1">
            <a href="#" style="color: #3863a0;"> <b>Open</b></a>
        	<input type="file" name="file_1" id="selectFile" class="file_input_hidden" accept="text/plain" id="selectFile" onclick="textFile()" />
        </div>
    </div>	
<!-- 텍스트창 -->
    <input style="top:70.5%; left:48.3%; border-radius: 4px;" type="text" id="fileName" class="file_input_textbox" readonly >
<!--이용방법  -->
<div class="button-1" style="top:71%; left: 34.3%;" onclick="alert('1)\n\'\'\'.txt파일에 숫자 공백 순으로 작성 ex) 1 5 2 4 3 \nOpen -> Sorting -> Save\n\n2)\nRandom, Nearly Sorted, Reversed중 택1 -> sorting -> save')">
        <a href="#" style="color: #3863a0;"> <b>How to use</b></a>
    </div>
<!-- 정렬 -->
    <div class="button-1" style="top:78%; left: 53%;" onclick="sortStart(); noodle();">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Sorting</b></a>
    </div>
<!--저장  -->
    <div class="button-1" style="top:78%; left: 60%;" onclick="saveToFile_Chrome('result.txt', array)">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;" ><b>Save</b></a>
    </div>

<!--랜덤숫자  -->
    <div class="button-1" style="top:78%; left: 29.3%;" onclick="randomArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Random</b></a>
    </div>

    <div class="button-1" style="top:78%; left: 36.3%; width: 140px;" onclick="nearlySortedArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Nearly Sorted</b></a>
    </div>
    
    <div class="button-1" style="top:78%; left: 46%;" onclick="reverseArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;" ><b>Reversed</b></a>
    </div>

    <h5 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:88.5%; left:27%; ">ALGORITHM: </h5>
    <div class="h-container" style="position: absolute; top: 94.5%; left: 29%;">
        <strong><a class="nexth" href="Bubble.html">Bubble</a></strong>
        <strong><a class="nexth" href="Selection.html">Selection</a></strong>
        <strong><a class="nexth" href="Insertion.html">Insertion</a></strong>
        <strong><a class="nexth" href="Merge.html">Merge</a></strong>
        <strong><a class="nexth" href="Heap.html">Heap</a></strong>
        <strong><a class="nexth" href="Quick.html">Quick</a></strong>
        <strong><a class="nexth" href="Count.html">Count</a></strong>
        <strong><a class="nexth" href="Radix.html">Radix</a></strong>
    </div>
    <div align="center" style="color: #3863a0; position:absolute; top:25%; left:27.5%; ">
  
        <span id="countdown"><strong>timer</strong></span>
        <br><br>
  
    </div>
    
    <script type="text/javascript"> 
        var array=[];

        function randomArray() {
            array=[];
            for(let i=0; i<100; i++) {
                var random = Math.floor(Math.random() * 101);
                array.push(random);
            }
            draw(array); 
        }
        function nearlySortedArray() {
            array=[];
            let tmpArray=[];
            for(let i=0; i<100; i++) {
                array[i] = i;
            }
            let tmp=array[3]; array[3]=array[6]; array[6]=tmp;
            tmp=array[7]; array[7]=array[15]; array[15]=tmp;
            tmp=array[12]; array[12]=array[17]; array[17]=tmp;
            tmp=array[57]; array[57]=array[43]; array[43]=tmp;
            tmp=array[26]; array[26]=array[38]; array[38]=tmp;
            tmp=array[93]; array[93]=array[76]; array[76]=tmp;
            tmp=array[78]; array[78]=array[64]; array[64]=tmp;
            tmp=array[49]; array[49]=array[66]; array[66]=tmp;
            tmp=array[34]; array[34]=array[57]; array[57]=tmp;
            tmp=array[87]; array[87]=array[99]; array[99]=tmp;
            draw(array); 
        }
        function reverseArray() {
            array=[];
            for(let i=0; i<100; i++) {
                array.push(100-i);
            }
            draw(array); 
        }

        function textFile(fileName) {
            document.getElementById('selectFile').onchange = function(e) {
                var file = e.target.files[0];
                document.getElementById('fileName').value = file.name;
                //파일 읽기
                var reader = new FileReader();
                reader.readAsText(file);
                //파일 읽기 성공시
                reader.onload = function(e) {
                    var textData = reader.result;
                    array = textData.split(" ");  // array배열에 공백 기준으로 삽입
                   
                    //정수형으로 변환
                    for(var i=0; i<array.length; i++) {
                        array[i] = Number(array[i]);
                    }
                    draw(array);
                }
            }
        }

        function saveToFile_Chrome(fileName, content) {
            var blob = new Blob([content], { type: 'text/plain' });
            objURL = window.URL.createObjectURL(blob);
                    
            // 이전에 생성된 메모리 해제
            if (window.__Xr_objURL_forCreatingFile__) {
                window.URL.revokeObjectURL(window.__Xr_objURL_forCreatingFile__);
            }
            window.__Xr_objURL_forCreatingFile__ = objURL;
            var a = document.createElement('a');
            a.download = fileName;
            a.href = objURL;
            a.click();
        }

        // canvas
        var CANVAS_WIDTH = window.innerWidth;
        var CANVAS_HEIGHT = window.innerHeight;

        var canvas = document.querySelector('canvas')
        var context = canvas.getContext('2d');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
            
        var _canvas = document.querySelector("#myCanvas");
        _canvas.width = 640;
        _canvas.height = 300;

        function draw(array, a, b,c){
            context.save();
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = 'white';
            context.beginPath();
            context.moveTo(0, canvas.height-100);
            context.lineTo(canvas.width, canvas.height-100);
            context.stroke();
            context.restore();
            context.fillStyle = 'black';
            for(let i=0; i < array.length; i++){
                if(i==a || i==b || i==c) {
                    context.fillStyle = '#4875b4';
                    context.fillRect(20+6*i,canvas.height-1, 5, -2.7 * array[i]);
                }
                else {
                    context.fillRect(20+6*i,canvas.height-1, 5, -2.7 * array[i]);
                }                                
            }
        }


        var left=[], right=[], result=[];
        var audio1 = new Audio('button-14.mp3');
        var audio2 = new Audio('button-18.mp3');
        var audio3 = new Audio('button-3.mp3');
        

        function sortStart() {
            count=0;

            mergeSort(array);
            function mergeSort(arr) {
                for(let i=1; i<array.length; i+=i) {

                    (function(x) {
                    setTimeout(function() {
                        audio3.play();
                    for(let j=0; j<array.length-i; j+=i+i) {
                            merge(arr, j, j+i-1, Math.min(j + i + i - 1, array.length - 1));
                            draw(arr, j, j+i-1, Math.min(j + i + i - 1, array.length - 1));
                        }
                    }, 100*x);
                })(i);
                }
            }     

            function merge(arr, start, mid, end) {
                //  arr[lo..hi]를 arrux[lo..hi]에 복제
                for (let k = start; k <= end; k++) {
                    result[k] = arr[k];
                }
                let i = start;       // sub 배열 1 인덱스
                let j = mid+1;  // sub 배열 2 인덱스
                // 다시 a[start..end]로 병합
                for (let k = start; k <= end; k++) {
                    if (i > mid) {
                        // sub 배열 1 인덱스가 마지막까지 갔다면 sub 배열 2의 값을 선택해 넣는다
                        arr[k] = result[j++];
                    } else if (j > end) {
                           // sub 배열 2 인덱스가 마지막까지 갔다면 sub 배열 1의 값을 선택해 넣는다
                        arr[k] = result[i++];
                    } else if (result[j] < result[i]) {
                        // 두 sub 배열 헤드 중 작은 값을 선택해 넣는다
                        arr[k] = result[j++];
                    } else {
                        // 두 sub 배열 헤드 중 작은 값을 선택해 넣는다
                        arr[k] = result[i++];
                    }
                }
            }

                /*
                left=[], right=[], result=[];
                let cnt=0, cnt1=0,cnt2=0,sa=0,sb=0;
                let middle=Math.floor(start+(end-start)/2);
                for(let i=start; i<middle; i++) {
                    left[cnt1]=arr[i];  cnt1++;
                }
                for(let i=middle; i<end; i++) {
                    right[cnt2]=arr[i]; cnt2++;
                }
                while(sa<cnt1 && sb<cnt2) {
                    if(left[sa]<=right[sb]) {
                        result[cnt] = left[sa]; sa++;
                    } else {result[cnt] = right[sb]; sb++;}
                    cnt++;
                }
                //나머지들
                while (sa < cnt1) {
                    result[cnt]=left[sa]; sa++; cnt++;
                } while (sb < cnt2) {
                    result[cnt]=right[sb]; sb++; cnt++;
                }
                cnt=0;
                for(let i=start; i<end; i++) {
                    arr[i] = result[cnt]; cnt++;
                }
                draw(result);
                return arr; 
            }*/
        }
        var count = 0;
    var time = 0;

    function noodle() {
        clearInterval(time); // 타이머 우선 초기화 시켜주기(time initialize)
        value=0;
        // 타이머 함수 1초씩 호출하는 함수 만들기
        time = setInterval("myTimer()", 1000);

    }

    function myTimer() {
        count = count + 1; // 타이머 선택 숫자에서 -1씩 감산함(갱신되기 때문)
        document.getElementById("countdown").innerHTML = "정렬 중 <b>" + count + "</b>초.";
        if (count>1) {
            var flag =0;
            for(var i=0; i<array.length; i++) {
                if(array[i]>array[i+1]) flag=1;
            }
            if(flag==0) {
                document.getElementById("countdown").innerHTML = "정렬 완료 <b>" + count + "</b>초.";
                clearInterval(time); // 시간 초기화
            }
        }
    }
    </script>

    <h3><a style="font-size: 20px; color: #0d0a33; position: absolute; top: 2.5%; margin-left:10px;" href="home.html"> Home </a></h3>
    <h3 style="font-size: 20px; color: #0d0a33; position: absolute; top: 0%; margin-left:85%;">201912430 조민서</h3>
</body=>
