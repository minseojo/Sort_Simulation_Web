<!DOCTYPE html>
<html lang="en">
<head>
    <title>Quick-Sort</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href ="style.css">
    <style>
        
ol { 
    font-size: 20px;
    text-align: right;
    position: absolute;
    top:80%;
    left:20%;
}
a { text-decoration:none;} 
a:link { color:#4875b4; font-size: 12px;}
a:visited { color:#4875b4;
font-size: 12px;}
    </style>
</head>
<body style="background-color: white;">

    <div style="border-bottom: 1px solid rgb(114, 110, 110); width: 95%; padding: 30px; margin-left: 0.5%;"> </div>

    <h1 style="color:#3863a0;; text-align-last: center; margin-top: 30px; margin-right: 20px;">Quick Sort</h1>
   
    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position: absolute; top:16%; left:0%;">ALGORITHM</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position: absolute; top:23%; left:2%; ">
        # choose pivot_<br>
        swap a[1,rand(1,n)]<br>
        <br>
        # 2-way partition_<br>
        k = 1<br>
        for i = 2:n, if a[i] < a[1], swap a[++k,i]<br>
        swap a[1,k]<br>
        → invariant: a[1..k-1] < a[k] <= a[k+1..n]_<br>
        <br>
        # recursive sorts_<br>
        sort a[1..k-1]<br>
        sort a[k+1,n]<br>
        end
    </span>
    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:16%; left:69.5%;">DISCUSSION</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position:absolute; top:23%; left:71.5%; width: 350px;">
        The 2-way partitioning code shown above is written for clarity rather 
        than optimal performance; it exhibits poor locality, and, critically, 
        exhibits O(n2) time when there are few unique keys. A more efficient and
         robust 2-way partitioning method is given in Quicksort is Optimal by 
         Robert Sedgewick and Jon Bentley. The robust partitioning produces 
         balanced recursion when there are many values equal to the pivot, 
         yielding probabilistic guarantees of O(n·lg(n)) time and O(lg(n)) space 
         for all inputs.
    </span>
    <canvas id="myCanvas" width="460" height="200"></canvas>
    <h3 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:65%; left:69.5%;">PROPERTIES</h3>
    <span class="sorting_algorithms_content" style="font-size: 15px; position:absolute; top:72%; left:71.5%">
        • Not stable<br>
        • O(lg(n)) extra space (see discussion)<br>
        • O(n2) time, but typically O(n·lg(n)) time<br>
        • Not adaptive<br>
    </span>
<!-- 오픈 -->
    <div class="file_input_div">
        <div class="button-1">
            <a href="#" style="color: #3863a0;"> <b>Open</b></a>
        	<input type="file" name="file_1" id="selectFile" class="file_input_hidden" accept="text/plain" id="selectFile" onclick="textFile()" />
        </div>
    </div>	
<!-- 텍스트창 -->
    <input style="top:70.5%; left:48.3%; border-radius: 4px;" type="text" id="fileName" class="file_input_textbox" readonly >
<!--이용방법  -->
<div class="button-1" style="top:71%; left: 34.3%;" onclick="alert('1)\n\'\'\'.txt파일에 숫자 공백 순으로 작성 ex) 1 5 2 4 3 \nOpen -> Sorting -> Save\n\n2)\nRandom, Nearly Sorted, Reversed중 택1 -> sorting -> save')">
        <a href="#" style="color: #3863a0;"> <b>How to use</b></a>
    </div>
<!-- 정렬 -->
    <div class="button-1" style="top:78%; left: 53%;" onclick="sortStart(); noodle();">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Sorting</b></a>
    </div>
<!--저장  -->
    <div class="button-1" style="top:78%; left: 60%;" onclick="saveToFile_Chrome('result.txt', array)">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;" ><b>Save</b></a>
    </div>

<!--랜덤숫자  -->
    <div class="button-1" style="top:78%; left: 29.3%;" onclick="randomArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Random</b></a>
    </div>

    <div class="button-1" style="top:78%; left: 36.3%; width: 140px;" onclick="nearlySortedArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;"> <b>Nearly Sorted</b></a>
    </div>
    
    <div class="button-1" style="top:78%; left: 46%;" onclick="reverseArray()">
        <div class="eff-1"></div>
        <a href="#" style="color: #3863a0;" ><b>Reversed</b></a>
    </div>

    <h5 style="color: #3863a0; margin-left: 30px; font-family:arial; position:absolute; top:88.5%; left:27%; ">ALGORITHM: </h5>
    <div class="h-container" style="position: absolute; top: 94.5%; left: 29%;">
        <strong><a class="nexth" href="Bubble.html">Bubble</a></strong>
        <strong><a class="nexth" href="Selection.html">Selection</a></strong>
        <strong><a class="nexth" href="Insertion.html">Insertion</a></strong>
        <strong><a class="nexth" href="Merge.html">Merge</a></strong>
        <strong><a class="nexth" href="Heap.html">Heap</a></strong>
        <strong><a class="nexth" href="Quick.html">Quick</a></strong>
        <strong><a class="nexth" href="Count.html">Count</a></strong>
        <strong><a class="nexth" href="Radix.html">Radix</a></strong>
    </div>
    <div align="center" style="color: #3863a0; position:absolute; top:25%; left:27.5%; ">
  
        <span id="countdown"><strong>timer</strong></span>
        <br><br>
  
    </div>
    
    <script type="text/javascript">
        var array=[];

        function randomArray() {
            array=[];
            for(let i=0; i<100; i++) {
                var random = Math.floor(Math.random() * 101);
                array.push(random);
            }
            draw(array); 
        }
        function nearlySortedArray() {
            array=[];
            let tmpArray=[];
            for(let i=0; i<100; i++) {
                array[i] = i;
            }
            let tmp=array[3]; array[3]=array[6]; array[6]=tmp;
            tmp=array[7]; array[7]=array[15]; array[15]=tmp;
            tmp=array[12]; array[12]=array[17]; array[17]=tmp;
            tmp=array[57]; array[57]=array[43]; array[43]=tmp;
            tmp=array[26]; array[26]=array[38]; array[38]=tmp;
            tmp=array[93]; array[93]=array[76]; array[76]=tmp;
            tmp=array[78]; array[78]=array[64]; array[64]=tmp;
            tmp=array[49]; array[49]=array[66]; array[66]=tmp;
            tmp=array[34]; array[34]=array[57]; array[57]=tmp;
            tmp=array[87]; array[87]=array[99]; array[99]=tmp;
            draw(array); 
        }
        function reverseArray() {
            array=[];
            for(let i=0; i<100; i++) {
                array.push(100-i);
            }
            draw(array); 
        }

        function textFile(fileName) {
            document.getElementById('selectFile').onchange = function(e) {
                var file = e.target.files[0];
                document.getElementById('fileName').value = file.name;
                //파일 읽기
                var reader = new FileReader();
                reader.readAsText(file);
                //파일 읽기 성공시
                reader.onload = function(e) {
                    var textData = reader.result;
                    array = textData.split(" ");  // array배열에 공백 기준으로 삽입
                   
                    //정수형으로 변환
                    for(var i=0; i<array.length; i++) {
                        array[i] = Number(array[i]);
                    }
                    draw(array);
                }
            }
        }

        function saveToFile_Chrome(fileName, content) {
            var blob = new Blob([content], { type: 'text/plain' });
            objURL = window.URL.createObjectURL(blob);
                    
            // 이전에 생성된 메모리 해제
            if (window.__Xr_objURL_forCreatingFile__) {
                window.URL.revokeObjectURL(window.__Xr_objURL_forCreatingFile__);
            }
            window.__Xr_objURL_forCreatingFile__ = objURL;
            var a = document.createElement('a');
            a.download = fileName;
            a.href = objURL;
            a.click();
        }

        // canvas
        var CANVAS_WIDTH = window.innerWidth;
        var CANVAS_HEIGHT = window.innerHeight;

        var canvas = document.querySelector('canvas')
        var context = canvas.getContext('2d');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
            
        var _canvas = document.querySelector("#myCanvas");
        _canvas.width = 640;
        _canvas.height = 300;

        var flag2=0;
        function draw(array, a, b){
            context.save();
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = 'white';
            context.beginPath();
            context.moveTo(0, canvas.height-100);
            context.lineTo(canvas.width, canvas.height-100);
            context.stroke();
            context.restore();
            context.fillStyle = 'black';
            for(let i=0; i < array.length; i++){
                if(i==a) {
                    context.fillStyle = '#4875b4';
                    context.fillRect(20+6*i,canvas.height-1, 5, -2.7 * array[i]);
                }
                else  {
                    context.fillRect(20+6*i,canvas.height-1, 5, -2.7 * array[i]);
                }

            }

        }

        var audio1 = new Audio('button-14.mp3');
        var audio2 = new Audio('button-18.mp3');
        var audio3 = new Audio('button-3.mp3');
        var audioArray = [];

        
        function sortStart() {
            var falg2=0;
            count=0;
            var cnt=0;
            for(let i=0; i<array.length; i++) {
                audioArray[i] = array[i];
            }
            quickSort(array); 
            /*
            원래는 아래에 있는 quickSort2가 맞으나 시각화하기 위해서 포문을 이용 i는 n~0으로 하향식 이동 i를 피벗으로 두고 하나씩 지정 
            => 마치 삽입과정과 비슷해 보이나 다르다.
            */
            function quickSort(arr) {
                for(let i=arr.length; i>0; i--) {
                    (function(x) {
                    setTimeout(function() {  
                        cnt++;
                        if(cnt==array.length-1) flag2=1;  
                        if(i/2==1 || i/4==1||i/8==1||i/16==1||i/32==1||i/64==1||i/99==1) audio3.play();                                         
                    for(let j=i-1; j>=0; j--) {
                        divide(arr, j, Math.min(arr.length-j-1, array.length-1),arr.length-i+1);
                    }
                    draw(arr, arr.length- i);
                    if(i==1) draw(arr, 0,0);                   
                    }, 65*x); // 기준원소를/2씩 하는게 아니라 1씩 감소하므로 다른거보다 속도를 올림
                })(i);
                }
            } 
            
            /* 원래 시각화용이 아니라면 맞는 퀵정렬
            function quickSort2 (array, left = 0, right = array.length - 1) {
                if (left >= right) {
                    return;
                }
                setTimeout( function() {           
                    const mid = Math.floor((left + right) / 2);
                    const pivot = array[mid];
                    const partition = divide(array, left, right, pivot); 
                    quickSort(array, left, partition - 1);
                    quickSort(array, partition, right);
                },500);
                return array;
            }*/
           /*
           function quickSort(arr) {
                for(let i=1; i<arr.length; i++) {
                    (function(x) {
                    setTimeout(function() {
                    for(let j=0; j<arr.length-i-1; j+=i+i) {
                        divide(arr, j, Math.min(arr.length-j-1, array.length-1), arr.length-i-1);
                        draw(arr, arr.length- i);
                    }
                    }, 50*x);
                })(i);
                }
            }*/
            function divide (array, left, right, pivot) {        
                while (left <= right) {
                    while (array[left] < pivot) {
                        left++;
                    }
                    while (array[right] > pivot) {
                        right--;
                    } 
                    if (left <= right) {
                        let tmp = array[left];
                        array[left] = array[right];
                        array[right] = tmp;
                        left++;
                        right--;
                    }          
                }
            }
        }
    var count = 0;
    var time = 0;

    function noodle() {
        clearInterval(time); // 타이머 우선 초기화 시켜주기(time initialize)
        value=0;
        // 타이머 함수 1초씩 호출하는 함수 만들기
        time = setInterval("myTimer()", 1000);
    }

    function myTimer() {
        count = count + 1; // 타이머 선택 숫자에서 -1씩 감산함(갱신되기 때문)
        document.getElementById("countdown").innerHTML = "정렬 중 <b>" + count + "</b>초.";
        if (count>1) {
            var flag =0;
            for(var i=0; i<array.length; i++) {
                if(array[i]>array[i+1]) flag=1;
            }
            if(flag==0 && flag2==1) {
                document.getElementById("countdown").innerHTML = "정렬 완료 <b>" + count + "</b>초.";
            clearInterval(time); // 시간 초기화
            }
        }
    }
    </script>
     <h3><a style="font-size: 20px; color: #0d0a33; position: absolute; top: 2.5%; margin-left:10px;" href="home.html"> Home </a></h3>
     <h3 style="font-size: 20px; color: #0d0a33; position: absolute; top: 0%; margin-left:85%;">201912430 조민서</h3>
</body=>
